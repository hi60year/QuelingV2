package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"main/graph/constants"
	"main/graph/model"
	"main/graph/utils"

	"github.com/dgryski/trifles/uuid"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// Teams is the resolver for the teams field.
func (r *contestResolver) Teams(ctx context.Context, obj *model.Contest) ([]*model.Team, error) {
	panic(fmt.Errorf("not implemented: Teams - teams"))
}

// Players is the resolver for the players field.
func (r *contestResolver) Players(ctx context.Context, obj *model.Contest) ([]*model.Player, error) {
	panic(fmt.Errorf("not implemented: Players - players"))
}

// InviteCode is the resolver for the inviteCode field.
func (r *contestResolver) InviteCode(ctx context.Context, obj *model.Contest, authorizationCode string) (string, error) {
	findOptions := options.FindOne().SetProjection(bson.M{
		"inviteCode":        1,
		"authorizationCode": 1,
	})

	id, _ := primitive.ObjectIDFromHex(obj.ID)

	filter := bson.D{{"_id", id}}

	type inviteCodePayload struct {
		InviteCode        string
		AuthorizationCode string
	}

	var result inviteCodePayload

	if err := r.db.Database(constants.QuelingDatabaseName).Collection(constants.ContestCollectionName).FindOne(ctx, filter, findOptions).Decode(&result); err != nil {
		return "", err
	} else {
		log.Print(authorizationCode, result.AuthorizationCode)
		if authorizationCode != result.AuthorizationCode {
			return "", fmt.Errorf("authorization failed")
		} else {
			return result.InviteCode, nil
		}
	}
}

// RegisterNewTeam is the resolver for the registerNewTeam field.
func (r *mutationResolver) RegisterNewTeam(ctx context.Context, registrationPayload *model.TeamRegistrationPayload, inviteCode *string) (*model.TeamRegistrationResult, error) {
	session, err := r.db.StartSession()
	if err != nil {
		return nil, err
	}
	defer session.EndSession(ctx)

	if err := session.StartTransaction(); err != nil {
		return nil, err
	}

	defer func() {
		if p := recover(); p != nil {
			if err := session.AbortTransaction(ctx); err != nil {
				log.Fatal(err)
			}
			panic(p)
		} else if err != nil {
			if abortErr := session.AbortTransaction(ctx); abortErr != nil {
				log.Fatal(abortErr)
			}
		} else {
			if commitErr := session.CommitTransaction(ctx); commitErr != nil {
				log.Fatal(commitErr)
			}
		}
	}()

	contestId, err := primitive.ObjectIDFromHex(registrationPayload.ContestID)
	if err != nil {
		return nil, err
	}

	var contestResult struct {
		InviteCode    string `json:"inviteCode"`
		MaxTeamMember int    `json:"maxTeamMember"`
	}

	err = r.db.Database(constants.QuelingDatabaseName).Collection(constants.ContestCollectionName).FindOne(
		ctx, bson.D{{"_id", contestId}}, options.FindOne().SetProjection(bson.M{
			"inviteCode":    1,
			"maxTeamMember": 1,
		})).Decode(&contestResult)

	if err != nil {
		return nil, err
	}

	if *inviteCode != contestResult.InviteCode {
		return &model.TeamRegistrationResult{
			Error: model.InviteCodeNotMatchError{Msg: "Wrong Invite Code"},
		}, nil
	}

	if len(registrationPayload.Players) >= contestResult.MaxTeamMember {
		return &model.TeamRegistrationResult{
			Error: model.MaxTeamMemberExceededError{MaxTeamMember: contestResult.MaxTeamMember, Msg: "Max Team Member Exceeded"},
		}, nil
	}

	_, err = utils.GetOne[model.Team](r.db, ctx, constants.TeamCollectionName, bson.D{
		{"name", registrationPayload.Name},
		{"contestId", contestId},
	})

	if err != nil && !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	if err == nil {
		return &model.TeamRegistrationResult{
			Error: model.TeamNameAlreadyExistError{Name: registrationPayload.Name, Msg: "Team Name Already Exists"},
		}, nil
	}

	var players []*model.Player

	for _, payload := range registrationPayload.Players {
		player, err := utils.PlayerFromPayload(payload, registrationPayload.ContestID)
		if err != nil {
			return nil, err
		}
		players = append(players, player)
	}

	teamForSubmission := model.Team{
		Players:     players,
		Name:        registrationPayload.Name,
		LeaderIndex: registrationPayload.LeaderIndex,
		ContestId:   registrationPayload.ContestID,
		ExtraInfo:   registrationPayload.ExtraInfo,
	}

	authorizationCode := uuid.UUIDv4()

	teamRegistrationSubmitPayload, _ := json.Marshal(teamForSubmission)
	var teamRegistrationSubmitPayloadMap map[string]any
	_ = json.Unmarshal(teamRegistrationSubmitPayload, &teamRegistrationSubmitPayloadMap)
	teamRegistrationSubmitPayloadMap["authorizationCode"] = authorizationCode
	teamRegistrationSubmitPayloadMap["contestId"] = contestId

	result, err := r.db.Database(constants.QuelingDatabaseName).Collection(constants.TeamCollectionName).InsertOne(ctx, teamRegistrationSubmitPayloadMap)
	if err != nil {
		return nil, err
	}

	var insertedId string

	switch id := result.InsertedID.(type) {
	case string:
		insertedId = id
	case primitive.ObjectID:
		insertedId = id.Hex()
	default:
		log.Fatal("Unknown InsertedID type")
	}

	err = nil

	return &model.TeamRegistrationResult{
		TeamID:            &insertedId,
		AuthorizationCode: &authorizationCode,
		Error:             nil,
	}, nil
}

// IsLeader is the resolver for the isLeader field.
func (r *playerResolver) IsLeader(ctx context.Context, obj *model.Player, teamID string) (bool, error) {
	team, err := utils.GetOneById[model.Team](r.db, ctx, constants.TeamCollectionName, teamID)
	if err != nil {
		return false, err
	} else if team.LeaderIndex == nil || *team.LeaderIndex < 0 || *team.LeaderIndex >= len(team.Players) {
		return false, nil
	} else {
		return team.Players[*team.LeaderIndex].ID == obj.ID, nil
	}
}

// TeamID is the resolver for the teamId field.
func (r *playerResolver) TeamID(ctx context.Context, obj *model.Player) (*string, error) {
	panic(fmt.Errorf("not implemented: TeamID - teamId"))
}

// Team is the resolver for the team field.
func (r *playerResolver) Team(ctx context.Context, obj *model.Player) (*model.Team, error) {
	panic(fmt.Errorf("not implemented: Team - team"))
}

// Contest is the resolver for the contest field.
func (r *playerResolver) Contest(ctx context.Context, obj *model.Player) (*model.Contest, error) {
	panic(fmt.Errorf("not implemented: Contest - contest"))
}

// PlayerByID is the resolver for the playerById field.
func (r *queryResolver) PlayerByID(ctx context.Context, id string) (*model.Player, error) {
	return utils.GetOneById[model.Player](r.db, ctx, constants.PlayerCollectionName, id)
}

// PlayersByName is the resolver for the playersByName field.
func (r *queryResolver) PlayersByName(ctx context.Context, name string) ([]*model.Player, error) {
	filter := bson.M{
		"name": bson.M{
			"$regex":   "^" + name,
			"$options": "i", // Case-insensitive search
		},
	}
	return utils.GetAllWithPagination[model.Player](r.db, ctx, constants.PlayerCollectionName, filter, 0)
}

// ContestByID is the resolver for the contestById field.
func (r *queryResolver) ContestByID(ctx context.Context, id string) (*model.Contest, error) {
	return utils.GetOneById[model.Contest](r.db, ctx, constants.ContestCollectionName, id)
}

// ContestsByName is the resolver for the contestsByName field.
func (r *queryResolver) ContestsByName(ctx context.Context, name string) ([]*model.Contest, error) {
	filter := bson.M{
		"name": bson.M{
			"$regex":   "^" + name,
			"$options": "i", // Case-insensitive search
		},
	}
	return utils.GetAllWithPagination[model.Contest](r.db, ctx, constants.ContestCollectionName, filter, 0)
}

// AllContests is the resolver for the allContests field.
func (r *queryResolver) AllContests(ctx context.Context, pageNum int) ([]*model.Contest, error) {
	return utils.GetAllWithPagination[model.Contest](r.db, ctx, constants.ContestCollectionName, bson.D{}, pageNum)
}

// AllContestsByRule is the resolver for the allContestsByRule field.
func (r *queryResolver) AllContestsByRule(ctx context.Context, rule *model.MahjongType, pageNum int) ([]*model.Contest, error) {
	return utils.GetAllWithPagination[model.Contest](r.db, ctx, constants.ContestCollectionName, bson.D{{"mahjongType", rule}}, pageNum)
}

// AllPlayers is the resolver for the allPlayers field.
func (r *queryResolver) AllPlayers(ctx context.Context, pageNum int) ([]*model.Player, error) {
	return utils.GetAllWithPagination[model.Player](r.db, ctx, constants.PlayerCollectionName, bson.D{}, pageNum)
}

// HasLeader is the resolver for the hasLeader field.
func (r *teamResolver) HasLeader(ctx context.Context, obj *model.Team) (bool, error) {
	return obj.LeaderIndex != nil, nil
}

// LeaderPlayer is the resolver for the leaderPlayer field.
func (r *teamResolver) LeaderPlayer(ctx context.Context, obj *model.Team) (*model.Player, error) {
	if obj.LeaderIndex == nil {
		return nil, fmt.Errorf("no leader specified")
	} else {
		if *obj.LeaderIndex < 0 || *obj.LeaderIndex >= len(obj.Players) {
			return nil, fmt.Errorf("invalid leader index value. expect a value in [0, %v], got %v",
				len(obj.Players), obj.LeaderIndex)
		}
	}
	return obj.Players[*obj.LeaderIndex], nil
}

// Status is the resolver for the status field.
func (r *teamResolver) Status(ctx context.Context, obj *model.Team) (*model.TeamStatus, error) {
	panic(fmt.Errorf("not implemented: Status - status"))
}

// Contest returns ContestResolver implementation.
func (r *Resolver) Contest() ContestResolver { return &contestResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Player returns PlayerResolver implementation.
func (r *Resolver) Player() PlayerResolver { return &playerResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Team returns TeamResolver implementation.
func (r *Resolver) Team() TeamResolver { return &teamResolver{r} }

type contestResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type playerResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type teamResolver struct{ *Resolver }
