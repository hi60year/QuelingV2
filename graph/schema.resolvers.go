package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"main/graph/constants"
	"main/graph/model"
	"main/graph/utils"

	"github.com/dgryski/trifles/uuid"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// Teams is the resolver for the teams field.
func (r *contestResolver) Teams(ctx context.Context, obj *model.Contest, pageNum int) ([]*model.Team, error) {
	id, _ := primitive.ObjectIDFromHex(obj.ID)
	return utils.GetAllWithPagination[model.Team](r.db, ctx, constants.TeamCollectionName, bson.D{{"contestId", id}}, pageNum)
}

// Players is the resolver for the players field.
func (r *contestResolver) Players(ctx context.Context, obj *model.Contest) ([]*model.Player, error) {
	panic(fmt.Errorf("not implemented: Players - players"))
}

// InviteCode is the resolver for the inviteCode field.
func (r *contestResolver) InviteCode(ctx context.Context, obj *model.Contest, authorizationCode string) (string, error) {
	findOptions := options.FindOne().SetProjection(bson.M{
		"inviteCode":        1,
		"authorizationCode": 1,
	})

	id, _ := primitive.ObjectIDFromHex(obj.ID)

	filter := bson.D{{"_id", id}}

	type inviteCodePayload struct {
		InviteCode        string
		AuthorizationCode string
	}

	var result inviteCodePayload

	if err := r.db.Database(constants.QuelingDatabaseName).Collection(constants.ContestCollectionName).FindOne(ctx, filter, findOptions).Decode(&result); err != nil {
		return "", err
	} else {
		log.Print(authorizationCode, result.AuthorizationCode)
		if authorizationCode != result.AuthorizationCode {
			return "", fmt.Errorf("authorization failed")
		} else {
			return result.InviteCode, nil
		}
	}
}

// CheckInviteCode is the resolver for the checkInviteCode field.
func (r *contestResolver) CheckInviteCode(ctx context.Context, obj *model.Contest, inviteCode string) (bool, error) {
	collection := r.db.Database(constants.QuelingDatabaseName).Collection(constants.ContestCollectionName)
	id, _ := primitive.ObjectIDFromHex(obj.ID)

	option := options.FindOne().SetProjection(bson.D{{
		"inviteCode", 1,
	}})

	result := collection.FindOne(ctx, bson.D{{"_id", id}}, option)

	var inviteCodeResponse struct {
		InviteCode string `json:"inviteCode"`
	}

	if err := result.Decode(&inviteCodeResponse); err != nil {
		return false, err
	} else {
		return inviteCodeResponse.InviteCode == inviteCode, nil
	}
}

// CheckTeamNameExist is the resolver for the checkTeamNameExist field.
func (r *contestResolver) CheckTeamNameExist(ctx context.Context, obj *model.Contest, name string) (bool, error) {
	id, _ := primitive.ObjectIDFromHex(obj.ID)
	_, err := utils.GetOne[model.Team](r.db, ctx, constants.TeamCollectionName, bson.D{
		{"contestId", id},
		{"name", name},
	})

	if errors.Is(err, mongo.ErrNoDocuments) {
		return false, nil
	} else {
		return true, err
	}
}

// AttendNum is the resolver for the attendNum field.
func (r *contestResolver) AttendNum(ctx context.Context, obj *model.Contest) (int, error) {
	collection := r.db.Database(constants.QuelingDatabaseName).Collection(constants.TeamCollectionName)
	id, _ := primitive.ObjectIDFromHex(obj.ID)
	pipeline := mongo.Pipeline{
		{{"$match", bson.D{{"contestId", id}}}},
		{{"$count", "attendNum"}},
	}

	var result struct {
		AttendNum int `json:"attendNum"`
	}

	cur, err := collection.Aggregate(ctx, pipeline)

	if err != nil {
		return 0, err
	}

	defer func() {
		err := cur.Close(ctx)
		if err != nil {
			log.Fatal(err)
		}
	}()

	if cur.Next(ctx) {
		err := cur.Decode(&result)
		if err != nil {
			return 0, err
		}
	} else {
		return 0, errors.New("no match found")
	}

	return result.AttendNum, err
}

// RegisterNewTeam is the resolver for the registerNewTeam field.
func (r *mutationResolver) RegisterNewTeam(ctx context.Context, registrationPayload *model.TeamRegistrationPayload, inviteCode *string) (registrationResult *model.TeamRegistrationResult, err error) {
	session, err := r.db.StartSession()
	if err != nil {
		return nil, err
	}
	defer session.EndSession(ctx)

	if err := session.StartTransaction(); err != nil {
		return nil, err
	}

	defer func() {
		if p := recover(); p != nil {
			if err := session.AbortTransaction(ctx); err != nil {
				log.Fatal(err)
			}
			panic(p)
		} else if err != nil {
			if abortErr := session.AbortTransaction(ctx); abortErr != nil {
				log.Fatal(abortErr)
			}
		} else {
			if commitErr := session.CommitTransaction(ctx); commitErr != nil {
				log.Fatal(commitErr)
			}
		}
	}()

	contestId, err := primitive.ObjectIDFromHex(registrationPayload.ContestID)
	if err != nil {
		return nil, err
	}

	var contestResult struct {
		InviteCode    string `json:"inviteCode"`
		MaxTeamMember int    `json:"maxTeamMember"`
	}

	err = r.db.Database(constants.QuelingDatabaseName).Collection(constants.ContestCollectionName).FindOne(
		ctx, bson.D{{"_id", contestId}}, options.FindOne().SetProjection(bson.M{
			"inviteCode":    1,
			"maxTeamMember": 1,
		})).Decode(&contestResult)

	if err != nil {
		return nil, err
	}

	if *inviteCode != contestResult.InviteCode {
		return &model.TeamRegistrationResult{
			Error: model.InviteCodeNotMatchError{Msg: "Wrong Invite Code"},
		}, nil
	}

	if len(registrationPayload.Players) >= contestResult.MaxTeamMember {
		return &model.TeamRegistrationResult{
			Error: model.MaxTeamMemberExceededError{MaxTeamMember: contestResult.MaxTeamMember, Msg: "Max Team Member Exceeded"},
		}, nil
	}

	_, err = utils.GetOne[model.Team](r.db, ctx, constants.TeamCollectionName, bson.D{
		{"name", registrationPayload.Name},
		{"contestId", contestId},
	})

	if err != nil && !errors.Is(err, mongo.ErrNoDocuments) {
		return nil, err
	}

	if err == nil {
		return &model.TeamRegistrationResult{
			Error: model.TeamNameAlreadyExistError{Name: registrationPayload.Name, Msg: "Team Name Already Exists"},
		}, nil
	}

	var players []*model.Player

	for _, payload := range registrationPayload.Players {
		player, err := utils.PlayerFromPayload(payload, registrationPayload.ContestID)
		if err != nil {
			return nil, err
		}
		players = append(players, player)
	}

	teamForSubmission := model.Team{
		Players:     players,
		Name:        registrationPayload.Name,
		LeaderIndex: registrationPayload.LeaderIndex,
		ContestId:   registrationPayload.ContestID,
		ExtraInfo:   registrationPayload.ExtraInfo,
		Status:      model.TeamStatusEditing,
	}

	authorizationCode := uuid.UUIDv4()

	teamRegistrationSubmitPayload, _ := json.Marshal(teamForSubmission)
	var teamRegistrationSubmitPayloadMap map[string]any
	_ = json.Unmarshal(teamRegistrationSubmitPayload, &teamRegistrationSubmitPayloadMap)
	teamRegistrationSubmitPayloadMap["authorizationCode"] = authorizationCode
	teamRegistrationSubmitPayloadMap["contestId"] = contestId

	result, err := r.db.Database(constants.QuelingDatabaseName).Collection(constants.TeamCollectionName).InsertOne(ctx, teamRegistrationSubmitPayloadMap)
	if err != nil {
		return nil, err
	}

	var insertedId string

	switch id := result.InsertedID.(type) {
	case string:
		insertedId = id
	case primitive.ObjectID:
		insertedId = id.Hex()
	default:
		log.Fatal("Unknown InsertedID type")
	}

	if err != nil {
		return nil, err
	}

	err = nil

	return &model.TeamRegistrationResult{
		TeamID:            &insertedId,
		AuthorizationCode: &authorizationCode,
		Error:             nil,
	}, nil
}

// UpdateTeam is the resolver for the updateTeam field.
func (r *mutationResolver) UpdateTeam(ctx context.Context, teamID string, updatePayload *model.TeamUploadPayload) (bool, error) {
	id, err := primitive.ObjectIDFromHex(teamID)
	if err != nil {
		return false, err
	}

	findOptions := options.FindOne().SetProjection(bson.M{"authorizationCode": 1})

	result := r.db.Database(constants.QuelingDatabaseName).Collection(constants.TeamCollectionName).FindOne(ctx, bson.D{{"_id", id}}, findOptions)

	var AuthorizationCodeWrapper struct {
		AuthorizationCode string `json:"authorizationCode"`
	}

	err = result.Decode(&AuthorizationCodeWrapper)

	if err != nil {
		return false, err
	}

	if AuthorizationCodeWrapper.AuthorizationCode != updatePayload.AuthorizationCode || AuthorizationCodeWrapper.AuthorizationCode == "" {
		return false, errors.New("authorization failed")
	}

	updatePayloadJsonData, err := json.Marshal(updatePayload)

	if err != nil {
		return false, err
	}

	updatePayloadJson := make(map[string]any)

	err = json.Unmarshal(updatePayloadJsonData, &updatePayloadJson)

	if err != nil {
		return false, err
	}

	updatePayloadJson["authorizationCode"] = nil

	update := bson.D{}

	for k, v := range updatePayloadJson {
		if v != nil {
			update = append(update, bson.E{Key: k, Value: v})
		}
	}

	_, err = r.db.Database(constants.QuelingDatabaseName).Collection(constants.TeamCollectionName).UpdateByID(ctx, id, bson.D{{"$set", update}})

	if err != nil {
		return false, err
	}

	return true, nil
}

// IsLeader is the resolver for the isLeader field.
func (r *playerResolver) IsLeader(ctx context.Context, obj *model.Player, teamID string) (bool, error) {
	team, err := utils.GetOneById[model.Team](r.db, ctx, constants.TeamCollectionName, teamID)
	if err != nil {
		return false, err
	} else if team.LeaderIndex == nil || *team.LeaderIndex < 0 || *team.LeaderIndex >= len(team.Players) {
		return false, nil
	} else {
		return team.Players[*team.LeaderIndex].ID == obj.ID, nil
	}
}

// TeamID is the resolver for the teamId field.
func (r *playerResolver) TeamID(ctx context.Context, obj *model.Player) (*string, error) {
	panic(fmt.Errorf("not implemented: TeamID - teamId"))
}

// Team is the resolver for the team field.
func (r *playerResolver) Team(ctx context.Context, obj *model.Player) (*model.Team, error) {
	panic(fmt.Errorf("not implemented: Team - team"))
}

// Contest is the resolver for the contest field.
func (r *playerResolver) Contest(ctx context.Context, obj *model.Player) (*model.Contest, error) {
	panic(fmt.Errorf("not implemented: Contest - contest"))
}

// PlayerByID is the resolver for the playerById field.
func (r *queryResolver) PlayerByID(ctx context.Context, id string) (*model.Player, error) {
	return utils.GetOneById[model.Player](r.db, ctx, constants.PlayerCollectionName, id)
}

// PlayersByName is the resolver for the playersByName field.
func (r *queryResolver) PlayersByName(ctx context.Context, name string) ([]*model.Player, error) {
	filter := bson.M{
		"name": bson.M{
			"$regex":   "^" + name,
			"$options": "i", // Case-insensitive search
		},
	}
	return utils.GetAllWithPagination[model.Player](r.db, ctx, constants.PlayerCollectionName, filter, 0)
}

// ContestByID is the resolver for the contestById field.
func (r *queryResolver) ContestByID(ctx context.Context, id string) (*model.Contest, error) {
	return utils.GetOneById[model.Contest](r.db, ctx, constants.ContestCollectionName, id)
}

// ContestsByName is the resolver for the contestsByName field.
func (r *queryResolver) ContestsByName(ctx context.Context, name string) ([]*model.Contest, error) {
	filter := bson.M{
		"name": bson.M{
			"$regex":   "^" + name,
			"$options": "i", // Case-insensitive search
		},
	}
	return utils.GetAllWithPagination[model.Contest](r.db, ctx, constants.ContestCollectionName, filter, 0)
}

// ContestNum is the resolver for the contestNum field.
func (r *queryResolver) ContestNum(ctx context.Context) (int, error) {
	count, err := r.db.Database(constants.QuelingDatabaseName).Collection(constants.ContestCollectionName).CountDocuments(ctx, bson.D{})
	if err != nil {
		return 0, err
	}
	return int(count), nil
}

// ComContestNum is the resolver for the comContestNum field.
func (r *queryResolver) ComContestNum(ctx context.Context) (int, error) {
	count, err := r.db.Database(constants.QuelingDatabaseName).Collection(constants.ContestCollectionName).CountDocuments(ctx, bson.D{{"mahjongType", "COM"}})
	if err != nil {
		return 0, err
	}
	return int(count), nil
}

// RiichiContestNum is the resolver for the riichiContestNum field.
func (r *queryResolver) RiichiContestNum(ctx context.Context) (int, error) {
	count, err := r.db.Database(constants.QuelingDatabaseName).Collection(constants.ContestCollectionName).CountDocuments(ctx, bson.D{{"mahjongType", "Riichi"}})
	if err != nil {
		return 0, err
	}
	return int(count), nil
}

// Teams is the resolver for the teams field.
func (r *queryResolver) Teams(ctx context.Context, id *string, contestID *string, name *string, pageNum int) ([]*model.Team, error) {
	filter := bson.D{}

	if id != nil {
		teamObjectId, err := primitive.ObjectIDFromHex(*id)
		if err != nil {
			return nil, err
		}
		filter = append(filter, bson.E{Key: "_id", Value: teamObjectId})
	}
	if contestID != nil {
		contestObjectId, err := primitive.ObjectIDFromHex(*contestID)
		if err != nil {
			return nil, err
		}
		filter = append(filter, bson.E{Key: "contestId", Value: contestObjectId})
	}
	if name != nil {
		filter = append(filter, bson.E{Key: "name", Value: bson.M{
			"$regex":   "^" + *name,
			"$options": "i", // Case-insensitive search
		}})
	}
	return utils.GetAllWithPagination[model.Team](r.db, ctx, constants.TeamCollectionName, filter, pageNum)
}

// TeamByID is the resolver for the teamById field.
func (r *queryResolver) TeamByID(ctx context.Context, id string) (*model.Team, error) {
	return utils.GetOneById[model.Team](r.db, ctx, constants.TeamCollectionName, id)
}

// AllContests is the resolver for the allContests field.
func (r *queryResolver) AllContests(ctx context.Context, pageNum int) ([]*model.Contest, error) {
	return utils.GetAllWithPagination[model.Contest](r.db, ctx, constants.ContestCollectionName, bson.D{}, pageNum)
}

// AllContestsByRule is the resolver for the allContestsByRule field.
func (r *queryResolver) AllContestsByRule(ctx context.Context, rule *model.MahjongType, pageNum int) ([]*model.Contest, error) {
	return utils.GetAllWithPagination[model.Contest](r.db, ctx, constants.ContestCollectionName, bson.D{{"mahjongType", rule}}, pageNum)
}

// AllPlayers is the resolver for the allPlayers field.
func (r *queryResolver) AllPlayers(ctx context.Context, pageNum int) ([]*model.Player, error) {
	return utils.GetAllWithPagination[model.Player](r.db, ctx, constants.PlayerCollectionName, bson.D{}, pageNum)
}

// HasLeader is the resolver for the hasLeader field.
func (r *teamResolver) HasLeader(ctx context.Context, obj *model.Team) (bool, error) {
	return obj.LeaderIndex != nil, nil
}

// LeaderPlayer is the resolver for the leaderPlayer field.
func (r *teamResolver) LeaderPlayer(ctx context.Context, obj *model.Team) (*model.Player, error) {
	if obj.LeaderIndex == nil {
		return nil, fmt.Errorf("no leader specified")
	} else {
		if *(obj.LeaderIndex) < 0 || *(obj.LeaderIndex) >= len(obj.Players) {
			return nil, fmt.Errorf("invalid leader index value. expect a value in [0, %v], got %v. team: %v",
				len(obj.Players), *obj.LeaderIndex, obj.Name)
		}
	}
	return obj.Players[*obj.LeaderIndex], nil
}

// Contest is the resolver for the contest field.
func (r *teamResolver) Contest(ctx context.Context, obj *model.Team) (*model.Contest, error) {
	if obj.ContestId == "" {
		return nil, errors.New("contestId must be fetched")
	} else {
		return utils.GetOneById[model.Contest](r.db, ctx, constants.ContestCollectionName, obj.ContestId)
	}
}

// CheckAuthorizationCode is the resolver for the checkAuthorizationCode field.
func (r *teamResolver) CheckAuthorizationCode(ctx context.Context, obj *model.Team, authorizationCode string) (bool, error) {
	collection := r.db.Database(constants.QuelingDatabaseName).Collection(constants.TeamCollectionName)
	id, _ := primitive.ObjectIDFromHex(obj.ID)

	option := options.FindOne().SetProjection(bson.D{{
		"authorizationCode", 1,
	}})

	result := collection.FindOne(ctx, bson.D{{"_id", id}}, option)

	var authorizationCodeResponse struct {
		AuthorizationCode string `json:"authorizationCode"`
	}

	if err := result.Decode(&authorizationCodeResponse); err != nil {
		return false, err
	} else {
		return authorizationCodeResponse.AuthorizationCode == authorizationCode, nil
	}
}

// Contest returns ContestResolver implementation.
func (r *Resolver) Contest() ContestResolver { return &contestResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Player returns PlayerResolver implementation.
func (r *Resolver) Player() PlayerResolver { return &playerResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Team returns TeamResolver implementation.
func (r *Resolver) Team() TeamResolver { return &teamResolver{r} }

type contestResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type playerResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type teamResolver struct{ *Resolver }
